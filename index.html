<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AAC NITK - Scientific Orrery</title>
    <!-- Three.js Core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Official OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <style>
        :root {
            --bg: #0b0c10;
            --panel: rgba(31, 40, 51, 0.9);
            --accent: #66fcf1;
            --text: #c5c6c7;
            --border: 1px solid rgba(102, 252, 241, 0.2);
            --font-ui: 'Segoe UI', system-ui, sans-serif;
            --font-mono: 'Consolas', monospace;
        }

        body { margin: 0; overflow: hidden; background: var(--bg); font-family: var(--font-ui); color: var(--text); }
        #container { width: 100vw; height: 100vh; }
        
        /* UI Layout */
        #ui-layer {
            position: absolute; top: 20px; left: 20px; width: 320px;
            display: flex; flex-direction: column; gap: 10px; z-index: 10; pointer-events: none;
        }
        
        .panel {
            background: var(--panel); backdrop-filter: blur(10px);
            padding: 15px; border-radius: 4px; border: var(--border);
            pointer-events: auto; box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }

        h1 {
            font-size: 14px; margin: 0 0 10px 0; color: var(--accent);
            text-transform: uppercase; letter-spacing: 2px; border-bottom: var(--border); padding-bottom: 5px;
        }

        .data-row {
            display: flex; justify-content: space-between;
            font-size: 11px; margin-bottom: 5px; font-family: var(--font-mono); color: #888;
        }
        .data-val { color: #fff; font-weight: 700; }

        /* Controls */
        input[type=range] { width: 100%; cursor: pointer; margin: 10px 0; }
        
        button {
            width: 100%; background: transparent; border: var(--border);
            color: var(--accent); padding: 8px; font-weight: 700; font-size: 10px;
            cursor: pointer; text-transform: uppercase; margin-top: 5px;
            transition: all 0.2s;
        }
        button:hover { background: var(--accent); color: #000; }
        button.active { background: var(--accent); color: #000; }

        /* Target Grid */
        .target-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 4px; margin-top: 10px; }
        .t-btn {
            padding: 5px; font-size: 9px; text-align: center; border: 1px solid #444;
            cursor: pointer; color: #888; transition: 0.2s;
        }
        .t-btn:hover { border-color: var(--accent); color: #fff; }
        .t-btn.active { background: var(--accent); color: #000; border-color: var(--accent); }

        /* Analytics */
        #analytics {
            position: absolute; top: 20px; right: 20px; width: 350px;
            background: var(--panel); border: var(--border); padding: 15px;
            display: none; pointer-events: auto; z-index: 20;
        }
        #analytics.visible { display: block; }
        
        .plot-box { margin-bottom: 15px; }
        .plot-header { font-size: 10px; color: #aaa; margin-bottom: 3px; display: flex; justify-content:space-between; }
        .cvs-wrap { width: 100%; height: 60px; background: rgba(0,0,0,0.3); border: 1px solid #333; }
        canvas { width: 100%; height: 100%; }

        /* Tooltip */
        #tooltip {
            position: absolute; background: rgba(0,0,0,0.9); border: 1px solid #555;
            color: #fff; padding: 8px; font-size: 10px; font-family: var(--font-mono);
            pointer-events: none; opacity: 0; transform: translate(-50%, -120%);
            z-index: 100;
        }
    </style>
</head>
<body>

<div id="container"></div>

<div id="ui-layer">
    <div class="panel">
        <h1>TRACKER</h1>
        <div class="data-row"><span>DATE</span> <span id="simDate" class="data-val">JAN 01 2000</span></div>
        <div class="data-row"><span>SPEED</span> <span id="timeScale" class="data-val">1.0 DAYS/TICK</span></div>
        
        <input type="range" id="speedSlider" min="0" max="50" step="0.1" value="1">
        
        <button id="btnPause">PAUSE TIME</button>
        <button id="btnView">VIEW: ORBIT</button>
        <button id="btnData" style="margin-top:10px; border-style:dashed;">SHOW TELEMETRY</button>

        <div style="margin-top:15px; border-top:var(--border); padding-top:10px;">
            <span style="font-size:10px; color:#666;">PRIMARY TARGET</span>
            <div class="target-grid" id="targetGrid"></div>
        </div>
    </div>
    
    <div class="panel" style="font-size:10px; color:#888;">
        <strong>NAV SYSTEMS (OrbitControls)</strong><br>
        L-Click: Rotate • R-Click: Pan • Scroll: Zoom
    </div>
</div>

<div id="analytics">
    <button onclick="document.getElementById('analytics').classList.remove('visible')" style="float:right; width:auto; padding:2px 6px; margin:0;">X</button>
    <h1>ORBITAL TELEMETRY</h1>
    
    <div class="plot-box">
        <div class="plot-header"><span>Target Distance (AU)</span> <span id="valDist" style="color:var(--accent)">--</span></div>
        <div class="cvs-wrap"><canvas id="plotDist"></canvas></div>
    </div>
    <div class="plot-box">
        <div class="plot-header"><span>Orbital Velocity (km/s)</span> <span id="valVel" style="color:#e040fb">--</span></div>
        <div class="cvs-wrap"><canvas id="plotVel"></canvas></div>
    </div>
</div>

<div id="tooltip"></div>

<script>
(function() { 

// =================================================================
// 1. SCIENTIFIC CORE: KEPLERIAN ELEMENTS (J2000)
// =================================================================
// These are not random numbers. These are the scientific orbital elements 
// relative to the J2000 epoch (Jan 1, 2000, 12:00 UTC).
// a: semi-major (AU), e: eccentricity, i: inclination (deg)
// L: mean longitude (deg), w: long. of perihelion (deg), O: long. of ascending node (deg)
// rate values are per century (Cy) or similar, simplified here for real-time calc.

const J2000 = 2451545.0; // Julian Date for J2000
const CY = 36525; // Days in a century

const PLANET_DATA = {
    Mercury: { a: 0.387098, e: 0.20563, i: 7.00, L: 252.25, w: 77.46, O: 48.33, n: 4.0923344368 },
    Venus:   { a: 0.723332, e: 0.00677, i: 3.39, L: 181.98, w: 131.53, O: 76.68, n: 1.6021302244 },
    Earth:   { a: 1.000000, e: 0.01671, i: 0.00, L: 100.46, w: 102.94, O: 0.00,  n: 0.9856082535 },
    Mars:    { a: 1.523679, e: 0.09340, i: 1.85, L: 355.45, w: 336.04, O: 49.58, n: 0.5240207766 },
    Jupiter: { a: 5.204267, e: 0.04849, i: 1.30, L: 34.40,  w: 14.75,  O: 100.56, n: 0.0830853001 },
    Saturn:  { a: 9.582017, e: 0.05555, i: 2.49, L: 49.94,  w: 92.43,  O: 113.72, n: 0.0334442282 },
    Uranus:  { a: 19.22941, e: 0.04717, i: 0.77, L: 313.23, w: 170.96, O: 74.23,  n: 0.011725806 },
    Neptune: { a: 30.06114, e: 0.00859, i: 1.77, L: 304.88, w: 44.97,  O: 131.72, n: 0.005995147 }
};

// Colors & Scales
const VISUALS = {
    Sun:     { r: 4.0, c: 0xffaa00, emit: true },
    Mercury: { r: 0.5, c: 0xaaaaaa },
    Venus:   { r: 0.9, c: 0xffd700 },
    Earth:   { r: 1.0, c: 0x2255ff, atmo: true },
    Mars:    { r: 0.7, c: 0xff4400 },
    Jupiter: { r: 2.4, c: 0xd4a373 },
    Saturn:  { r: 2.1, c: 0xe3d081, ring: true },
    Uranus:  { r: 1.6, c: 0x40e0d0 },
    Neptune: { r: 1.6, c: 0x3333ff }
};

class EphemerisSystem {
    constructor() {
        this.julianDate = J2000;
        this.bodies = {};
    }

    update(daysToAdd) {
        this.julianDate += daysToAdd;
        const d = this.julianDate - J2000; // Days since J2000

        for (const [name, data] of Object.entries(PLANET_DATA)) {
            // 1. Calculate Mean Anomaly (M)
            // n is degrees per day
            let M = (data.L - data.w + data.n * d) % 360;
            if (M < 0) M += 360;
            const M_rad = M * Math.PI / 180;

            // 2. Solve Kepler's Equation for Eccentric Anomaly (E)
            // M = E - e*sin(E). Iterative solution.
            let E = M_rad;
            let delta = 1.0;
            let iters = 0;
            while (Math.abs(delta) > 1e-6 && iters < 10) {
                delta = E - data.e * Math.sin(E) - M_rad;
                E = E - delta / (1 - data.e * Math.cos(E));
                iters++;
            }

            // 3. True Anomaly (v) and Radius (r)
            // Calculate coordinates in orbital plane
            const xv = data.a * (Math.cos(E) - data.e);
            const yv = data.a * Math.sqrt(1 - data.e*data.e) * Math.sin(E);
            
            const v = Math.atan2(yv, xv); // True anomaly in rads
            const r = Math.sqrt(xv*xv + yv*yv); // Distance in AU

            // 4. Heliocentric Coordinates (3D Space)
            // Rotate by Longitude of Ascending Node (O), Argument of Perihelion (w), Inclination (i)
            const O_rad = data.O * Math.PI / 180;
            const w_rad = data.w * Math.PI / 180;
            const i_rad = data.i * Math.PI / 180;

            // Compute position
            const x = r * (Math.cos(O_rad) * Math.cos(v + w_rad - O_rad) - Math.sin(O_rad) * Math.sin(v + w_rad - O_rad) * Math.cos(i_rad));
            const y = r * (Math.sin(O_rad) * Math.cos(v + w_rad - O_rad) + Math.cos(O_rad) * Math.sin(v + w_rad - O_rad) * Math.cos(i_rad));
            const z = r * (Math.sin(v + w_rad - O_rad) * Math.sin(i_rad));

            // Velocity (Vis-viva estimate for analytics)
            // v = sqrt(GM(2/r - 1/a)) - In normalized units GM ~ 39.478 (using 4pi^2)
            const GM = 39.478; 
            const velMag = Math.sqrt(GM * (2/r - 1/data.a));

            // Store result (Swap Y/Z for Three.js: Physics Z is Up, Three Y is Up)
            this.bodies[name] = { 
                pos: new THREE.Vector3(x, z, y), // Mapping to X, Z, Y
                r: r,
                v: velMag
            };
        }
    }
    
    getDateString() {
        // Convert JD to readable date
        // Simplified calculation for display
        const date = new Date("2000-01-01T12:00:00Z");
        const diffDays = this.julianDate - J2000;
        date.setDate(date.getDate() + diffDays);
        return date.toDateString().toUpperCase();
    }
}

// =================================================================
// 2. THREE.JS VISUALIZATION
// =================================================================
let scene, camera, renderer, controls, sunLight;
let meshes = {};
let trails = {};
let eph = new EphemerisSystem();
let isPaused = false;
let timeScale = 1.0;
let targetName = "Sun";
let viewMode = "ORBIT"; // ORBIT or OBSERVE

function init() {
    // Scene
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0b0c10, 0.002);

    // Camera
    camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 10000);
    camera.position.set(0, 40, 60);

    // Renderer
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.domElement.id = 'simCanvas';
    document.getElementById('container').appendChild(renderer.domElement);

    // CONTROLS (Standard Lib)
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 5;
    controls.maxDistance = 500;

    // Lighting
    const ambient = new THREE.AmbientLight(0x222222);
    scene.add(ambient);
    
    sunLight = new THREE.PointLight(0xffddaa, 2.0, 1000);
    scene.add(sunLight);

    // Objects
    createStarfield();
    createSolarSystem();
    createUI();

    // Loop
    animate();
}

function createSolarSystem() {
    // Sun
    const sunGeo = new THREE.SphereGeometry(VISUALS.Sun.r, 32, 32);
    const sunMat = new THREE.MeshBasicMaterial({ color: VISUALS.Sun.c });
    const sunMesh = new THREE.Mesh(sunGeo, sunMat);
    scene.add(sunMesh);
    meshes['Sun'] = sunMesh;
    
    // Sun Glow
    const glowMat = new THREE.SpriteMaterial({ 
        map: new THREE.CanvasTexture(generateGlowTexture()), 
        color: 0xffaa00, 
        blending: THREE.AdditiveBlending 
    });
    const glow = new THREE.Sprite(glowMat);
    glow.scale.set(15, 15, 1);
    sunMesh.add(glow);

    // Planets
    for(const name in PLANET_DATA) {
        const conf = VISUALS[name];
        
        // Mesh
        const geo = new THREE.SphereGeometry(1, 32, 32); // Base size 1, scale later
        const mat = new THREE.MeshStandardMaterial({ 
            color: conf.c, 
            roughness: 0.7, 
            metalness: 0.1 
        });
        const mesh = new THREE.Mesh(geo, mat);
        const s = conf.r * 0.5;
        mesh.scale.set(s, s, s);
        
        // Atmosphere (Earth)
        if(conf.atmo) {
            const atmo = new THREE.Mesh(
                new THREE.SphereGeometry(1.2, 32, 32),
                new THREE.MeshBasicMaterial({ color: 0x44aaff, transparent: true, opacity: 0.2, blending: THREE.AdditiveBlending })
            );
            mesh.add(atmo);
        }

        // Ring (Saturn)
        if(conf.ring) {
            const ringGeo = new THREE.RingGeometry(1.4, 2.2, 64);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0xcbb677, side: THREE.DoubleSide, transparent: true, opacity: 0.6 });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = Math.PI/2;
            mesh.add(ring);
        }

        scene.add(mesh);
        meshes[name] = mesh;

        // Trail (LineLoop for orbits)
        // Pre-calculate orbit for display
        const trailGeo = new THREE.BufferGeometry();
        const pts = [];
        // Calculate one full orbit for trace
        const periodApprox = Math.pow(PLANET_DATA[name].a, 1.5) * 365;
        const tempEph = new EphemerisSystem();
        tempEph.julianDate = J2000;
        
        for(let i=0; i<=100; i++) {
            tempEph.update(periodApprox/100);
            pts.push(tempEph.bodies[name].pos.x, tempEph.bodies[name].pos.y, tempEph.bodies[name].pos.z);
        }
        trailGeo.setAttribute('position', new THREE.Float32BufferAttribute(pts, 3));
        const trail = new THREE.Line(trailGeo, new THREE.LineBasicMaterial({ color: conf.c, transparent:true, opacity:0.3 }));
        scene.add(trail);
    }
}

function generateGlowTexture() {
    const cvs = document.createElement('canvas'); cvs.width = 64; cvs.height = 64;
    const ctx = cvs.getContext('2d');
    const g = ctx.createRadialGradient(32,32,0, 32,32,32);
    g.addColorStop(0, 'rgba(255,255,255,1)');
    g.addColorStop(0.4, 'rgba(255,200,100,0.5)');
    g.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = g; ctx.fillRect(0,0,64,64);
    return cvs;
}

function createStarfield() {
    const geo = new THREE.BufferGeometry();
    const pos = []; const col = []; const c = new THREE.Color();
    for(let i=0; i<3000; i++) {
        const x = (Math.random()-0.5)*2000;
        const y = (Math.random()-0.5)*2000;
        const z = (Math.random()-0.5)*2000;
        pos.push(x,y,z);
        c.setHSL(Math.random(), 0.5, 0.8);
        col.push(c.r, c.g, c.b);
    }
    geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
    geo.setAttribute('color', new THREE.Float32BufferAttribute(col, 3));
    const mat = new THREE.PointsMaterial({ size:1.2, vertexColors:true, transparent:true, opacity:0.8 });
    scene.add(new THREE.Points(geo, mat));
}

// =================================================================
// 3. UI & ANALYTICS
// =================================================================
function createUI() {
    // Generate Target Buttons
    const grid = document.getElementById('targetGrid');
    ['Sun', ...Object.keys(PLANET_DATA)].forEach(name => {
        const btn = document.createElement('div');
        btn.className = `t-btn ${name==='Sun'?'active':''}`;
        btn.innerText = name.toUpperCase();
        btn.onclick = () => {
            targetName = name;
            document.querySelectorAll('.t-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
        };
        grid.appendChild(btn);
    });

    // Event Listeners
    document.getElementById('speedSlider').addEventListener('input', (e) => {
        timeScale = parseFloat(e.target.value);
        document.getElementById('timeScale').innerText = timeScale.toFixed(1) + " DAYS/TICK";
    });

    document.getElementById('btnPause').addEventListener('click', function() {
        isPaused = !isPaused;
        this.innerText = isPaused ? "RESUME TIME" : "PAUSE TIME";
        this.classList.toggle('active');
    });

    document.getElementById('btnView').addEventListener('click', function() {
        viewMode = viewMode === 'ORBIT' ? 'OBSERVE' : 'ORBIT';
        this.innerText = viewMode === 'ORBIT' ? 'VIEW: ORBIT' : 'VIEW: OBSERVATORY';
        this.classList.toggle('active');
    });

    document.getElementById('btnData').addEventListener('click', function() {
        const el = document.getElementById('analytics');
        el.classList.toggle('visible');
        this.classList.toggle('active');
    });

    // Resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Raycaster for Tooltips
    const ray = new THREE.Raycaster();
    const ptr = new THREE.Vector2();
    window.addEventListener('mousemove', (e) => {
        ptr.x = (e.clientX/window.innerWidth)*2 - 1;
        ptr.y = -(e.clientY/window.innerHeight)*2 + 1;
        ray.setFromCamera(ptr, camera);
        
        const hits = ray.intersectObjects(Object.values(meshes));
        const tip = document.getElementById('tooltip');
        if(hits.length > 0) {
            let obj = hits[0].object;
            // Traverse up if we hit a child (like ring/atmo)
            while(obj.parent && obj.parent.type === 'Mesh') obj = obj.parent;
            // Find name
            const name = Object.keys(meshes).find(key => meshes[key] === obj);
            if(name) {
                tip.style.opacity = 1;
                tip.style.left = e.clientX + 'px';
                tip.style.top = e.clientY + 'px';
                tip.innerText = name.toUpperCase();
            }
        } else {
            tip.style.opacity = 0;
        }
    });
}

// Plotting
const pDist = initPlot('plotDist', '#66fcf1');
const pVel = initPlot('plotVel', '#e040fb');

function initPlot(id, color) {
    const cvs = document.getElementById(id);
    cvs.width = cvs.offsetWidth; cvs.height = cvs.offsetHeight;
    return { ctx: cvs.getContext('2d'), data: [], color: color, w:cvs.width, h:cvs.height };
}

function drawPlot(p, val) {
    p.data.push(val);
    if(p.data.length > 100) p.data.shift();
    
    const ctx = p.ctx;
    ctx.clearRect(0,0,p.w,p.h);
    
    // Scale
    let min = Math.min(...p.data);
    let max = Math.max(...p.data);
    let range = max - min;
    if(range === 0) range = 1;

    ctx.strokeStyle = p.color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    for(let i=0; i<p.data.length; i++) {
        const x = (i/99) * p.w;
        const n = (p.data[i] - min) / range;
        const y = p.h - (n * (p.h*0.8) + p.h*0.1); // 10% padding
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
}

// =================================================================
// 4. MAIN LOOP
// =================================================================
function animate() {
    requestAnimationFrame(animate);

    if (!isPaused) {
        eph.update(timeScale); // Update Physics by Date
        document.getElementById('simDate').innerText = eph.getDateString();
    }

    // Sync Meshes
    for (const [name, mesh] of Object.entries(meshes)) {
        if(name === 'Sun') continue;
        const data = eph.bodies[name];
        mesh.position.copy(data.pos);
    }

    // Camera Logic
    const targetMesh = meshes[targetName];
    if (targetMesh) {
        const tPos = targetMesh.position;
        
        // Update Controls Target
        controls.target.lerp(tPos, 0.1);

        if (viewMode === 'OBSERVE' && targetName !== 'Sun') {
            // "North Pole" Observatory View
            // Need radius of planet. Simplification: scale is radius*0.5 in init.
            // But we didn't store raw radius. Let's approx based on planet list index or visuals.
            // Better: just offset Y by small amount relative to scale.
            const offset = targetMesh.scale.y * 1.5; 
            const obsPos = tPos.clone().add(new THREE.Vector3(0, offset, 0));
            camera.position.lerp(obsPos, 0.1);
            camera.lookAt(0,0,0); // Look at Sun
        }
    }
    
    controls.update(); // Standard OrbitControls update

    // Update Analytics
    if (targetName !== 'Sun' && eph.bodies[targetName]) {
        const d = eph.bodies[targetName];
        drawPlot(pDist, d.r);
        drawPlot(pVel, d.v * 4.74); // Convert AU/yr to km/s approx
        document.getElementById('valDist').innerText = d.r.toFixed(3);
        document.getElementById('valVel').innerText = (d.v * 4.74).toFixed(1);
    }

    renderer.render(scene, camera);
}

// Boot
init();

})(); 
</script>
</body>
</html>